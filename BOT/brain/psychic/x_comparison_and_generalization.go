/*
	Сопоставление и обобщение в системе Beast

Общеразделяемые определения.
Операция обобщения — логическая операция, в процессе которой производится переход от понятия с меньшим объемом к понятию с большим объемом; при этом содержание понятия становится беднее. В основе операции обобщения — отношение подчинения.
Обобщение как операция мышления включает в себя отбрасывание единичных признаков при сохранении общих, с раскрытием существенных связей.
Обобще́ние поня́тий — логическая операция, посредством которой в результате исключения видового признака получается другое понятие более широкого объёма, но менее конкретного содержания; форма превращения знания путём мысленного перехода от частного к общему в некоторой модели мира, что обычно соответствует и переходу на более высокую ступень абстракции.

Сопоставление и обобщение в системе Beast применяется на 5-й стадии развития, при работе с доминантами нерешенной проблемы.

Пример: "если человек вошёл в комнату и увидел детей, держащих в руках фломастеры, а затем увидел каракули на всех стенах, логика подсказала бы, что на основании представленной информации дети рисовали фломастерами на стенах."
ЭТО НЕ ЛОГИКА
"дети с фломастерами и разрисованные стены" позволяют сразу сделать вывод о том, что стены разрисовали дели фломастерами, а не инопланетяне с целью ввести в заблуждение. У размышления была цель: понять причину разрисованности стен. Модель стен имеет кадры опыта, когда взрослый видел разрисовывающих детей, при сопоставлении с моделью стен (фактически тот же опыт) сразу возникает самый общий результат, и цель размышления достигается. При этом нет никаких логических рассуждений по формальным правилам какой-то из логик. А есть просто результат обобщения моделей.

Обобщение всегда сводится к выявлению "длинных" Правил.
Простое Правило - это Стимул->Ответ->Эффект, а длинное может состоять из нескольких стимулов подряд, нескольких ответов и одного общего эффекта.
Образ "цифра два" вместе с образом "операция сложения" и с образом "цифра три" дает составной Стимул обобщения.
Образ составного действия, которое определяет алгоритм в отношении обработки образов стимула дает Ответ обобщения
Эффект же зависит от того, насколько верным оказывается Ответ. В разных условиях Эффект одного обобщения может оказаться разным.

Дерево эпиз.памяти, хранящее простые Правила является самым примитивным видом обобщения. Но из нескольких таких правил (сопоставляемых между собой) может быть сформировано одно обобщение, которое включает в себя некоторые или все сопоставляемые правила.

Кроме того, при сопоставлении образов длинного текста, содержащего слова с известным смыслом (Модель понимания образов), могут выявляться обобщающие их сочетания и строится предполагаемое обобщающее правило, которое замет может быть проверено в подходящих условиях (наличие сочетания стимулов обобщения) реальным запуском Ответа данного обобщения.
При неполном распознавании фразы тоже нужно обобщение (var curActiveActionsPhraseNonRecognised=false// не была распознана фраза).
При синтезе новой фразы func infoFunc12 - используются длинные правила.

В mental_memories.go уже заготовлены глобальные массивы памяти для обобщений, которые, видимо, НЕНУЖНЫ:
var saveBaseLinksCicleSynthesis []*int
var SynthesizeImportanceMemory []*SynthesizeImportanceImage

В принципе вся информация для обобщений есть в эпиз.памяти. НО
В структуре автоматизма возможно ветвление цепочки действий:
Automatizm.ActionsImageID -> Automatizm.NextID
В структуре самого действия тоже есть ветвление:
ActionsImage.ActID []int если член ActID имеет ID>prefixActionIdValue
*/
package psychic

import (
	word_sensor "BOT/brain/words_sensor"
)

//////////////////////////////////////////////////////// TODO

/*
для неопределенной фразы
найти слово в стимуле правил для текущих условий и более общих, но не во всей эп.памяти

	оценивая значимость стимула с таким словом и игнорируя малую значимость.
	Вернуть акцию наиболее успешного правила

# Для func infoFunc300
Новые фразы:
привет тебе!
ты очень классный
ну-ка играй
Возвращает массиы ID действий с позитивным Эфектом
*/
func getBestActionFromWordID(wordArr []int) int {
	/* !!! если нераспознана фраза, то detectedActiveLastNodID НЕВЕРЕН его нельзя использовать как поиск по эп.памяти
	поэтому нужно использовать lastWellPhrasedetectedActiveLastNodID
	Но func getWellRulesFromWordId и не испоьзует detectedActiveLastNodID
	а поиск только по узлу настроения и эмоции.
	*/

	var rullArr []Rule
	for i := 0; i < len(wordArr); i++ {
		if wordArr[i] == -1 {
			continue
		}
		// сначала смотрим правила в которых есть такое слово
		exactly := true //точно для условий выдать []Rule для данного ID фразы с позитивным Эффектом
		rArr := getWellRulesFromWordId(wordArr[i], exactly)
		if rArr != nil {
			for j := 0; j < len(rArr); j++ {
				rullArr = append(rullArr, rArr[j])
			}
			_, r := findBestRule(rullArr)
			if r.Action > 0 {
				return r.Action
			}
		}

		exactly = false // выдать []Rule для данного ID фразы с позитивным Эфектом
		rArr = getWellRulesFromWordId(wordArr[i], exactly)
		if rArr != nil {
			for j := 0; j < len(rArr); j++ {
				rullArr = append(rullArr, rArr[j])
			}
			_, r := findBestRule(rullArr)
			if r.Action > 0 {
				return r.Action
			}
		}
	}

	return 0
}

///////////////////////////////////////////////////////////

/*
	найти в неопределенной фразе что-то ранее встречающееся и выдать известные образы

# Для func infoFunc300
Новые фразы:
привет тебе!
ты очень классный
ну-ка играй
Возвращает массиы ID действий с позитивным Эфектом
*/
func prepareUnrecognizedPhrase(fraseArr []int) int {

	// по каждой фразе анализируем и при уверенном результате даже не смотрим дальше, а используем этот результат
	for i := 0; i < len(fraseArr); i++ {
		if fraseArr[i] == -1 { // фраза не распознанна
			continue
		}
		// сначала смотрим правила в которых есть такая фраза
		exactly := true //точно для условий выдать []Rule для данного ID фразы с позитивным Эффектом
		rArr := getWellRoolesFromPhraseId(fraseArr[i], exactly)
		if rArr != nil {
			_, r := findBestRule(rArr)
			if r.Action > 0 {
				return r.Action
			}
		}

		exactly = false // выдать []Rule для данного ID фразы с позитивным Эфектом
		rArr = getWellRoolesFromPhraseId(fraseArr[i], exactly)
		if rArr != nil {
			_, r := findBestRule(rArr)
			if r.Action > 0 {
				return r.Action
			}
		}

		wArr := word_sensor.GetWordsArrFromPraseID(fraseArr[i])
		if wArr != nil {
			wordsModel := getWordArrModelExactly(wArr)
			if wordsModel.beastFrameID > 0 { // ID наилучшего по эффекту кадра памяти
				actionNode, ok := ReadeEpisodicTreeNodeFromID(wordsModel.beastFrameID)
				if ok {
					return actionNode.Action
				}
			}
		}
	}

	return 0
}

///////////////////////////////////////////////////////////

/*
	Анализировать длинную или недоопределенную фразу, найти обобщающие данные и что-то сделать

# Для func infoFunc30

Привет!
Хочу научить тебя простым вещам.
Для начала давай усвоим длинные тексты.
В них могут попадаться знакомые значащие слова вроде улыбнуться, давай учить, бестолочь.
Ты должен найти их, выделить правила и обобщить слова в ответное общее действие.

GetPhraseStringsFromPhraseID выдает результат:
привет!#хочу научить тебя простым вещам.#для начала давай усвоим длинные тексты.#в них могут попадаться знакомые значащие слава вроде улыбнуться, давай учить, бестолочь.#ты должен найти их, выделить правила и обобщить слава в ответное общее действие.

Возвращает
*/
func preparelongPhrase(fraseArr []int) bool {
	//	var lineArr [][]int
	//	s := ""

	// по каждой фразе анализируем и при уверенном результате даже не смотрим дальше, а используем этот результат
	for i := 0; i < len(fraseArr); i++ {
		if fraseArr[i] == -1 { // фраза не распознанна
			continue
		}
		// сначала смотрим правила в которых есть такая фраза
		exactly := true //точно для условий выдать []Rule для данного ID фразы с позитивным Эфектом
		rArr := getWellRoolesFromPhraseId(fraseArr[i], exactly)
		if rArr != nil {

			// TODO что-то сделать с этим массивовм правил
			return true
		}

		exactly = false // выдать []Rule для данного ID фразы с позитивным Эфектом
		rArr = getWellRoolesFromPhraseId(fraseArr[i], exactly)
		if rArr != nil {

			// TODO что-то сделать с этим массивовм правил
			return true
		}

		wArr := word_sensor.GetWordsArrFromPraseID(fraseArr[i])
		if wArr != nil {
			wordsModel := getWordArrModelExactly(wArr)
			if wordsModel.beastFrameID > 0 || wordsModel.worstFrameID > 0 { // есть значения

				// TODO что-то сделать с этим результатом
				return true
			}
		}

		// ничего не обнаружено

		/*		wArr := word_sensor.GetWordsArrFromPraseID(fraseArr[i])
				if wArr == nil {
					continue
				}
				lineArr = append(lineArr, wArr)
				// проверка
				for n := len(wArr) - 1; n >= 0; n-- {
					s += word_sensor.GetWordFromWordID(wArr[n]) + " "
				}
				s += "\n" */
	} //for i := 0; i < len(fraseArr); i++ {

	/*	if lineArr == nil { // нет строк сообщения
			return
		}
		for i := 0; i < len(lineArr); i++ {

		}*/
	return false
}

///////////////////////////////////////////////////////////
